<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
    </head>
    <body>
        <canvas id="c"></canvas>
        <script id="vertex-shader-2d" type="notjs">
 
            // 一个属性变量，将会从缓冲中获取数据
            attribute vec4 a_position;
           
            uniform vec2 u_resolution;

            // 所有着色器都有一个main方法
            void main() {
              //convert the position from pixels to 0.0 to 1.0
              vec2 zeroToOne = a_position.xy / u_resolution;

              //convert from 0->1 to 0->2
              vec2 zeroToTwo = zeroToOne * 2.0;

              //convert from 0->2 to -1->+1 (clipspace)
              vec2 clipSpace = zeroToTwo - 1.0;

              gl_Position = vec4(clipSpace * vec2(1,-1),0,1);
            }
           
          </script>
           
          <script id="fragment-shader-2d" type="notjs">
           
            // 片段着色器没有默认精度，所以我们需要设置一个精度
            // mediump是一个不错的默认值，代表“medium precision”（中等精度）
            precision mediump float;
           
            void main() {
              // gl_FragColor是一个片段着色器主要设置的变量
              gl_FragColor = vec4(1, 0, 0.5, 1); // 返回“瑞迪施紫色”
            }
           
          </script>
          <script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
    </body>
    <script>
        /* eslint no-console:0 consistent-return:0 */
        "use strict";
        var canvas = document.querySelector("#c");


        function main() {
            var canvas = document.querySelector("#c");
            var gl = canvas.getContext("webgl");
            if(!gl){
                return ;
            }

            // use our boilerplate utils to compile the shaders and link into a program
            var program = webglUtils.createProgramFromScripts(gl,['vertex-shader-2d','fragment-shader-2d']);

            //look up where the vertex data needs to go.
            var positionAttributeLocation = gl.getAttribLocation(program,'a_position')

            //look up uniform locations
            var resolutionUniformLocation = gl.getUniformLocation(program,'u_resolution');

            //Create a buffer to put three 2d clip space points in 
            var  positionBuffer = gl.createBuffer();

            //Bind it to ARRAY_BUFFER(think of it as ARRAY_BUFFER = positionBuffer)
            gl.bindBuffer(gl.ARRAY_BUFFER,positionBuffer);

            var positions = [
                10,20,
                80,20,
                10,30,
                10,30,
                80,20,
                80,30,
            ];

            gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(positions),gl.STATIC_DRAW);

            webglUtils.resizeCanvasToDisplaySize(gl.canvas);

            //Tell WebGL how to convert from clip space to pixels
            gl.viewport(0,0,gl.canvas.width,gl.canvas.height);

            //Clear th canvas
            gl.clearColor(0,0,0,0)
            gl.clear(gl.COLOR_BUFFER_BIT);

            //Tell it to use our program(pair of shaders)
            gl.useProgram(program);

            //Turn on the attribute
            gl.enableVertexAttribArray(positionAttributeLocation);

            //Bind the position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER,positionBuffer);

            // Tell the attribute ow to get data out of positionBuffer (ARRAY_BUFFER)
            var size = 2;          // 2 components per iteration
            var type = gl.FLOAT;    // the data is 32bit floats
            var normalize = false; // don't normalize the data
            var stride = 0;        // 0 = move forward size * sizeof(type) each miteration to get the next position
            var offset = 0;        // start at the beginning of the buffer
            gl.vertexAttribPointer(positionAttributeLocation,size,type,normalize,stride,offset);

            //set the resolution
            gl.uniform2f(resolutionUniformLocation,gl.canvas.width,gl.canvas.height);

            //draw

            var primitiveType = gl.TRIANGLES;
            var offset = 0;
            var count = 6;
            gl.drawArrays(primitiveType,offset,count);
        }

        main();  

    </script>
</html>