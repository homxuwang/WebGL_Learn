<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        @import url("https://webglfundamentals.org/webgl/resources/webgl-tutorials.css");
        body {
        margin: 0;
        }
        canvas {
        width: 100vw;
        height: 100vh;
        display: block;
        }

    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <div id="uiContainer">
        <div id="ui">
          <div id="x"></div>
          <div id="y"></div>
          <div id="angle"></div>
          <div id="scaleX"></div>
          <div id="scaleY"></div>
        </div>
      </div>
    <script id="vertex-shader-2d" type="x-shader/x-vertex">
        attribute vec2 a_position;
        attribute vec4 a_color;

        uniform mat3 u_matrix;
        
        varying vec4 v_color;
        
        void main() {
          // Multiply the position by the matrix.
          gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
        
          //直接把属性值中的数据赋给可变量
          v_color = a_color;
        }
    </script>
    <!-- fragment shader -->
    <script id="fragment-shader-2d" type="x-shader/x-fragment">
        precision mediump float;

        varying vec4 v_color;
        
        void main() {
          gl_FragColor = v_color;
        }
    </script>
    <script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/m3.js"></script>
</body>
<script>
    /* eslint no-console:0 consistent-return:0 */
    "use strict";
    function createShader(gl,type,source){
        var shader = gl.createShader(type); //创建着色器对象
        gl.shaderSource(shader,source); //提供数据源
        gl.compileShader(shader); //编译 —>生成着色器
        var success = gl.getShaderParameter(shader,gl.COMPILE_STATUS);
        if(success){
            return shader
        }

        console.log(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader)
    }

    function createProgram(gl,vertexShader,fragmentShader){
        var program = gl.createProgram();
        gl.attachShader(program,vertexShader);
        gl.attachShader(program,fragmentShader);
        gl.linkProgram(program);
        var success = gl.getProgramParameter(program,gl.LINK_STATUS);
        if(success){
            return program;
        }

        console.log(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
    }
    function main() {
        var canvas = document.querySelector("#canvas");
        var gl = canvas.getContext("webgl");
        if(!gl){
            return;
        }

        var vertexShaderSource = document.querySelector("#vertex-shader-2d").text
        var fragmentShaderSource = document.querySelector("#fragment-shader-2d").text

        var vertexShader = createShader(gl,gl.VERTEX_SHADER,vertexShaderSource);
        var fragmentShader = createShader(gl,gl.FRAGMENT_SHADER,fragmentShaderSource);
        // setup GLSL program
        var program = createProgram(gl,vertexShader,fragmentShader);

        //look up where the vertex data needs to go.
        var positionLocation = gl.getAttribLocation(program,"a_position");
        var colorLocation = gl.getAttribLocation(program,"a_color");
        // lookup uniforms
        var matrixLocation = gl.getUniformLocation(program,"u_matrix")

        //Create a buffer
        var positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,positionBuffer);
        //Set geometry
        setGeometry(gl);

        //给颜色数据创建一个缓冲
        var colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,colorBuffer);
        //设置颜色
        setColor(gl);
        

        var translation = [200,150];
        var angleInRadians = 0;
        var scale = [1,1];

        drawScene();


         // Setup a ui.
        webglLessonsUI.setupSlider("#x", {value: translation[0], slide: updatePosition(0), max: gl.canvas.width });
        webglLessonsUI.setupSlider("#y", {value: translation[1], slide: updatePosition(1), max: gl.canvas.height});
        webglLessonsUI.setupSlider("#angle", {slide: updateAngle, max: 360});
        webglLessonsUI.setupSlider("#scaleX", {value: scale[0], slide: updateScale(0), min: -5, max: 5, step: 0.01, precision: 2});
        webglLessonsUI.setupSlider("#scaleY", {value: scale[1], slide: updateScale(1), min: -5, max: 5, step: 0.01, precision: 2});

        function updatePosition(index){
            return function(event,ui){
                translation[index] = ui.value
                drawScene();
            }
        }

        function updateAngle(event,ui){
            var angleInDegrees = 360 - ui.value;
            angleInRadians = angleInDegrees * Math.PI / 180;
            drawScene();
        }

        function updateScale(index){
            return function(event,ui){
                scale[index] = ui.value
                drawScene();
            }
        }
        //Draw the scene
        function drawScene() {
            webglUtils.resizeCanvasToDisplaySize(gl.canvas);

            //Tell WebGL how to convert from clip space to pixels
            gl.viewport(0,0,gl.canvas.width,gl.canvas.height);

            //Clear the canvas
            gl.clear(gl.COLOR_BUFFER_BIT);

            //Tell it to use our program(pair of shaders)
            gl.useProgram(program);

            //Turn on the attribute
            gl.enableVertexAttribArray(positionLocation)
              // Bind the position buffer.
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            //Tell the attribute how to get data out of positionBuffer(ARRAY_BUFFER)
            var size = 2; //2 components per iteration
            var type = gl.FLOAT
            var normalize = false;
            var stride = 0;
            var offset = 0;

            gl.vertexAttribPointer(positionLocation,size,type,normalize,stride,offset);

            // Turn on the color attribute
            gl.enableVertexAttribArray(colorLocation);
            //Bind the color buffer
            gl.bindBuffer(gl.ARRAY_BUFFER,colorBuffer)

            var size2 = 4; //2 components per iteration
            var type2 = gl.FLOAT
            var normalize2 = false;
            var stride2 = 0;
            var offset2 = 0;

            gl.vertexAttribPointer(colorLocation,size2,type2,normalize2,stride2,offset2);
            //Compute the matrix
            var matrix = m3.projection(gl.canvas.clientWidth,gl.canvas.clientHeight)
            matrix = m3.translate(matrix,translation[0],translation[1]);
            matrix = m3.rotate(matrix,angleInRadians);
            matrix = m3.scale(matrix,scale[0],scale[1])

            //Set the matrix
            gl.uniformMatrix3fv(matrixLocation,false,matrix);

            //Draw the geometry
            var primitiveType = gl.TRIANGLES;
            var offset = 0;
            var count = 6;
            gl.drawArrays(primitiveType,offset,count);

           
        }
    }

    function setColor(gl){
        //生成两个随机颜色
        var r1 = Math.random()
        var g1 = Math.random()
        var b1 = Math.random()

        var r2 = Math.random()
        var g2 = Math.random()
        var b2 = Math.random()

        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(
                [
                    // r1,g1,b1,1,
                    // r1,g1,b1,1,
                    // r1,g1,b1,1,
                    // r2,g2,b2,1,
                    // r2,g2,b2,1,
                    // r2,g2,b2,1,
                    Math.random(),Math.random(),Math.random(),1,
                    Math.random(),Math.random(),Math.random(),1,
                    Math.random(),Math.random(),Math.random(),1,
                    Math.random(),Math.random(),Math.random(),1,
                    Math.random(),Math.random(),Math.random(),1,
                    Math.random(),Math.random(),Math.random(),1,
                ]
            ),
            gl.STATIC_DRAW
        )
    }

    function setGeometry(gl){
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array([
                -150, -100,
                150,-100,
                -150,100,
                150,-100,
                -150,100,
                150,100
            ]),
            gl.STATIC_DRAW
        )
    }
    

    main();


</script>

</html>